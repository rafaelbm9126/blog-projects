---
import ArticleLayout from '@layouts/ArticleLayout.astro';
import Section from '@components/Section.svelte';
import Container from '@components/Container.svelte';
import ShowImage from '@components/ShowImage.astro';
import Summary from '@components/Summary.svelte';
import Note from '@components/Note.svelte';
import Paragraph from '@components/Paragraph.svelte';
import SubTitleXL from '@/components/SubTitleXL.svelte';
import List from '@components/List.svelte';
import SubTitleXS from '@/components/SubTitleXS.svelte';
import GithubButton from '@components/GithubButton.svelte';
import Link from '@components/Link.svelte';
import Code from '@components/Code.svelte';

import data from '@data/articles/1';

import ZeroImage from '@assets/zero.svg';
import BstImage from '@assets/bst.png';
---

<ArticleLayout
	title={data.title}
	description={data.description}
	keywords={data.keywords}
	date={data.date}
>
	<Section aria='General concept of Ziglang'>
		<Container bottom={6}>
			<ShowImage src={ZeroImage} href='https://github.com/ziglang/logo' />
		</Container>
		<Container bottom={6}>
			<Summary>
				"Ziglang is a programming language designed for efficiency, safety, and simplicity. With a
				focus on readability and low-level control, Ziglang empowers developers to create robust,
				high-performance software while maintaining a clear and elegant codebase."
			</Summary>
		</Container>
		<Container bottom={12}>
			<Note>
				Visit for more information
				<Link href='https://ziglang.org/' arialabel='Ziglang page'>ZigLang</Link> Or 
				<Link href='https://ziglang.org/documentation/master' arialabel='Ziglang documentation page'>
					ZigLang Doc
				</Link>
			</Note>
		</Container>
	</Section>

	<Section aria='Definition of binary search tree'>
		<Container bottom={6}>
			<ShowImage src={BstImage} href='https://en.wikipedia.org/wiki/Binary_search_tree' background />
		</Container>
		<Container bottom={12}>
			<Paragraph>
				A binary search tree (BST) is a hierarchical data structure in which each node has, at most,
				two children: a left child and a right child. Values in the nodes are organized in a way that
				smaller values are in the left subtree, and larger values are in the right subtree. This
				enables efficient data retrieval and search since a "divide and conquer" approach can be
				applied to locate specific elements. Binary search trees are commonly used in applications
				where quick access to ordered data is required.
			</Paragraph>
		</Container>
	</Section>

	<Section aria='Create struct'>
		<Container bottom={6}>
			<SubTitleXL>We create a data structure</SubTitleXL>
		</Container>
		<Container bottom={6}>
			<Code language={data.code[0].language} code={data.code[0].text} client:only />
		</Container>
		<Container bottom={4}>
			<Paragraph>
				The structure (struct) is used to define the data model that the binary tree will follow. It
				includes the following attributes:
			</Paragraph>
		</Container>
		<Container bottom={12}>
			<List
				list={[
					`data: This represents the value associated with each node and is used
							for ordering.`,
					`left: This pointer guides the branches, sub-branches, and nodes on the
							left side.`,
					`right: This pointer guides the branches, sub-branches, and nodes on
							the right side.`
				]}
			/>
		</Container>
	</Section>

	<Section aria='Definition allocator'>
		<Container bottom={6}>
			<SubTitleXL>ArenaAllocator?</SubTitleXL>
		</Container>
		<Container bottom={6}>
			<Paragraph>
				In Ziglang, the ArenaAllocator function is used to allocate and manage memory efficiently.
				This function creates a contiguous "arena" of memory, meaning it allocates memory blocks
				sequentially. The advantage of using an ArenaAllocator lies in its efficiency and simplicity,
				as it doesn't suffer from memory fragmentation, simplifies memory management, and allows for
				efficient deallocation of all allocated memory at once.
			</Paragraph>
		</Container>
		<Container bottom={6}>
			<Code language={data.code[1].language} code={data.code[1].text} client:only />
		</Container>
		<Container bottom={12}>
			<Paragraph>
				In summary, ArenaAllocator in Ziglang is a tool that facilitates orderly and efficient memory
				allocation and management, which can be especially useful in situations where precise memory
				control is needed and fragmentation issues are to be avoided.
			</Paragraph>
		</Container>
	</Section>

	<Section aria='Function insert node'>
		<Container bottom={6}>
			<SubTitleXL>Insert Node</SubTitleXL>
		</Container>
		<Container bottom={6}>
			<Code language={data.code[2].language} code={data.code[2].text} client:only />
		</Container>
		<Container bottom={12}>
			<Paragraph>
				The rule applied for sorting is as follows: If the node is null, we store the first value as
				the root. In the case that it is not null, we evaluate the following: if it is smaller than
				the previous value, we place it in the left branch, and if it is greater, we place it in the
				right branch. This process is repeated every time a new value is
			</Paragraph>
		</Container>
	</Section>

	<Section aria='Read functions'>
		<Container bottom={6}>
			<SubTitleXL>Types of traversals</SubTitleXL>
		</Container>

		<Section aria='Function pre-order'>
			<Container bottom={4}>
				<SubTitleXS>Pre-Order</SubTitleXS>
			</Container>
			<Container bottom={4}>
				<Paragraph>
					The pre-order traversal in a binary tree is an exploration technique that starts by visiting
					the root node, then moves to the left subtree, and finally to the right subtree. This process
					is repeated recursively for each node in the tree.
				</Paragraph>
			</Container>
			<Container bottom={8}>
				<Code language={data.code[3].language} code={data.code[3].text} client:only />
			</Container>
		</Section>

		<Section aria='Function in-order'>
			<Container bottom={4}>
				<SubTitleXS>In-Order</SubTitleXS>
			</Container>
			<Container bottom={4}>
				<Paragraph>
					In-order traversal in a binary tree is an exploration method that begins by visiting the left
					subtree, then the root node, and finally the right subtree recursively. This process is
					repeated for each node in the tree.
				</Paragraph>
			</Container>
			<Container bottom={8}>
				<Code language={data.code[4].language} code={data.code[4].text} client:only />
			</Container>
		</Section>

		<Section aria='Function post-order'>
			<Container bottom={4}>
				<SubTitleXS>Post-Order</SubTitleXS>
			</Container>
			<Container bottom={4}>
				<Paragraph>
					Post-order traversal in a binary tree is an exploration method that starts by visiting the
					left subtree, then the right subtree, and finally the root node recursively. This process is
					repeated for each node in the tree.
				</Paragraph>
			</Container>
			<Container bottom={12}>
				<Code language={data.code[5].language} code={data.code[5].text} client:only />
			</Container>
		</Section>
	</Section>

	<Section aria='Function main'>
		<Container bottom={6}>
			<SubTitleXL>Here is where the execution begins</SubTitleXL>
		</Container>
		<Container bottom={12}>
			<Code language={data.code[6].language} code={data.code[6].text} client:only />
		</Container>
	</Section>

	<Section aria='Note about repository'>
		<Container bottom={12}>
			<Note>
				<strong>Note:</strong>
				 In the repository, there are two functions, maxDepth and isBalanced, that I have not included
				since this tutorial is meant to provide a basic idea of how to work with a binary search tree.
			</Note>
		</Container>
	</Section>

	<Section aria='Github repository'>
		<Container>
			<GithubButton url={data.api_url} repo={data.repo_url} client:load />
		</Container>
	</Section>
</ArticleLayout>

<style></style>
